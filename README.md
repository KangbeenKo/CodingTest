# Programmers_CodingTest

## C

**1. 2016년**<br/>

![2016년P](https://user-images.githubusercontent.com/76294398/104171021-588c5300-5445-11eb-94a4-5a3f07b064aa.jpg)<br/><br/>
프로그래머스에서 코딩테스트 연습 Lv.1을 선택하면 제일 처음 나타나는 문제이다.<br/>
대략 만 명 정도가 푼, 다소 쉬운 문제라고 할 수 있다.<br/><br/>
날짜를 입력 받아 2016년 a월 b일이 무슨 요일인지 맞추는 프로그램을 작성하면 된다.<br/><br/>
제한조건에 의하면, 2016년은 윤년이므로 2월이 29일까지 있음을 알 수 있다. 이 부분에서 어이없이 실수했다면<br/>
3월 이상에서는 답이 제대로 나오지 않았을 것이다.<br/><br/>
리턴할 값은 메모리를 동적 할당해주라는 문구가 보이고, 그 아래 malloc함수가 보인다.<br/><br/>
return할 값인 answer을 malloc을 사용하여 동적 할당 해주어야 할 것 같다.<br/><br/>
week라는 7칸의 배열을 만들고 그 안에 요일을 넣었다. 그런데, 보통이랑은 다른 점이 눈에 띤다.<br/>
보통의 경우 일요일이나 월요일부터 작성하는데, 이 코드에서는 목요일(THU)부터 작성하였다.<br/>
그 이유는 2016년 1월1일이 금요일이기 때문이다.<br/><br/>
무슨 말인지 잘 생각해보자. 1월 1일이 금요일인 경우, 7일 뒤인 1월 8일에 다시 금요일이 돌아온다.<br/>
즉, a월 b일까지의 일수(1월 1일 포함)에 7을 나눈 나머지가 1이 되면 금요일, 0이 되면 목요일이 된다.<br/>
따라서, 0번째 배열에는 목요일인 THU, 1번째 배열에는 금요일인 FRI...와 같은 순서대로 요일이 들어가게 된다.<br/>
7로 나눈 나머지와 해당 배열의 n번째 요일이 일치하게 되는 것이다.<br/><br/>
그 다음으로는 month라는 13칸의 배열을 만들어 각 월의 전체 일수를 저장하였다. 여기서도 독특한 점이 보이는데,<br/>
12월 체계를 따른 12칸이 아닌 13칸이라는 점이다. 이는 이후 계산 방식에 따른 특징이다.<br/><br/> 
for문을 보면, sum이라는 초기값 0의 변수에 i가 a-1이 될 때까지 month배열 내의 수를 더한다.<br/>
이때 만약 a가 1, 즉 1월 b일이 입력될 경우, 아직 한 달이 채 지나지 않았으므로 '월'에 의한 날짜증가는 이루어지지 않기 때문이다.<br/><br/> 
이렇게 a월 b일에 의한 날짜증가가 이루어져 sum 이라는 변수에 저장된 후, sum을 7로 나눈 나머지를 answer로 반환하면 해당 날짜에 대한 요일이 반환된다.<br/><br/>


**2. 두 정수 사이 합**<br/>

![두정합](https://user-images.githubusercontent.com/76294398/104171722-6ee6de80-5446-11eb-9baf-cdb68ad66402.jpg)<br/><br/>
프로그래머스 코딩테스트 Lv.1 두 번째 문제이다.<br/>
약 만 이천 명 정도가 푼 문제이므로 이 또한 쉬운 축에 든다고 할 수 있다.<br/><br/>
두 정수 a와 b를 입력받은 후, 입력받은 두 정수 사이에 있는 정수들의 합을 구하는 소스코드를 작성해야 한다.<br/>
제한 조건에 의하면 a와 b의 대소 관계는 정해져 있지 않으므로 어느 것이 더 큰 수 인지 판별하는 과정이 필요할 듯하다.<br/><br/>
두 수가 같을 경우 아무 수나 리턴하라고 하였으니 그냥 a를 리턴하기로 하자.<br/>
a와 b가 ±10,000,000의 범위를 가지는 탓에 둘 사이 정수의 합이 굉장히 커질 수 있으므로 int가 아닌 long long을 사용한다.<br/><br/>
일단 먼저, 조건문을 사용하여 a와 b가 같을 경우 a를 리턴하도록 하였다.<br/><br/>
조건문은 위에서부터 참 거짓을 판별하여 조건이 참일 경우 해당 조건문 안의 함수를 실행하여 리턴 값을 반환한 후 조건문을 종료한다.<br/>
따라서 첫 번째 조건문의 조건이 거짓일 경우(a와 b가 같지 않을 경우) 그 아래의 조건문을 차례로 실행한다.<br/><br/>
a와 b가 같지 않다면, 둘 중 어느 하나는 다른 하나에 비해 클 것이므로 그에 대한 조건문을 작성해 준다.<br/>
만약 항상 a가 작고 b가 크다면 else 문만을 이용하면 되지만 그렇지 않기에 if 문을 한 번 더 사용해 준다.<br/><br/>
이렇게, a와 b 중 어느 것이 더 큰 지 판별했다면, 이제 계산을 실행해야 한다.<br/>
조건문 내에 반복문인 for 문을 사용하여 작은 수부터 큰 수까지 반복함으로써 answer을 갱신하고 반복문이 종료됨과 동시에 answer을 리턴한다.<br/><br/>

**3. 수박수박수박수박수박수?**<br/>

![수박](https://user-images.githubusercontent.com/76294398/104172118-1401b700-5447-11eb-92ca-40e9de23db14.jpg)<br/><br/>
프로그래머스 코딩테스트 Lv.1 세 번째 문제이다.<br/><br/>
약 만 이천 명 정도가 풀었으니 이 또한 쉬운 문제 같았으나 생각보다 어려웠다.<br/><br/>
어째서 지금까지의 문제들보다 많은 사람들이 풀었는지 의문이다. 오히려 적당히 어려워서 그런 걸까?<br/><br/>
'수'와 '박'을 번갈아가면서 n 개의 문자를 출력하는 소스코드를 작성해야 한다.<br/><br/>
제한 조건은 딱히 고려할 게 없다.<br/><br/>
첫 번째 문제와 마찬가지로 리턴할 값인 answer을 동적 할당해 주어야 한다.<br/>
일단 동적 할당을 해줘야 한다.<br/><br/>
한글은 2Byte니까 2Byte*n 칸이 필요하니 char* answer = (char*)malloc(sizeof(char) * 2 * n);로 해주면 된다.<br/>
...라고 생각하기 쉽지만 그렇지 않다.<br/><br/>
문자열의 마지막에는 '\0', 즉 NULL 값이 들어가기 때문이다. '수'나 '박'도 마찬가지다. 사실 '수'가 아닌 '수\0'이라는 뜻이다.<br/>
따라서 한글 2Byte + NULL 문자 1Byte = 3Byte를 필요로 한다.<br/><br/>
여기서 잠시 strcat 함수를 살펴봐야 한다.<br/><br/>
strcat(str1, str2); //str1 문자열 뒤에 str2 문자열을 복사해서 붙여 넣음<br/><br/>
앞에서 설명하였듯이, 모든 문자열의 마지막에는 NULL 문자가 붙어 해당 문자열의 끝을 알려준다.<br/>
str1 문자열과 str2문자열 모두 마찬가지로 마지막에는 NULL 문자가 들어간다.<br/>
그런데 strcat 함수를 사용하면 str1의 \0이 저장된 위치부터 덧붙여진다.<br/><br/>
이 소스코드의 경우<br/><br/>
n=2 //수\0 + 박\0<br/>
n=3 //수박\0 + 수\0<br/>
n=4 //수박수\0 + 박\0<br/>
n=5 //수박수박\0 + 수\0<br/>
...<br/><br/>
이런 식으로 진행된다는 소리다.<br/><br/>
따라서, char* answer = (char*)malloc(sizeof(char) * (2 * n + 1));을 해주면 된다.<br/>
다만, 어째서인지 프로그래머스에서는 3Byte로 취급되는지<br/>
char* answer = (char*)malloc(sizeof(char) * 3 * n);을 해주어야 실행 시 적절하게 모든 케이스를 통과할 수 있다.<br/><br/> 
아마 strcat을 고려하지 않고 '수\0'를 3Byte로 취급하는 탓인 듯하다.<br/><br/>
이제 동적 할당은 완료했다. 그런데 이렇게 동적 할당만 해주고 실행하면 이상한 한자가 출력된다.<br/><br/>
문자열을 malloc을 통해서 동적 할당을 하면 동적 할당한 칸에는 쓰레기 값들이 들어가게 된다.<br/>
이러한 쓰레기 값을 제거해 주지 않으면 쓰레기 값들, 즉 이상한 한자 뒤에 수박수박...이 출력된다.<br/><br/>
이 쓰레기 값을 제거해 주는 것이 memset 함수이다.<br/><br/>
memset 함수의 원형은 memset (포인터, 값, 크기);이다.<br/>
포인터 변수에서 크기만큼의 바이트를 값으로 바꾸는 함수이다.<br/>
즉,  memset(answer, NULL, sizeof(answer));는 answer 변수에서 sizeof(answer) 바이트만큼을<br/>
NULL 값으로 바꾸어 쓰레기 값을 청소해 주는 코드이다.<br/><br/>
이렇게 할당된 값을 청소까지 해주고 나면 이제 값을 넣을 차례다.<br/><br/>
int i = 1부터 i가 n이 될 때까지 while 반복문으로 반복을 해준다.<br/>
그리고 i를 2로 나눈 나머지가 0이 아닐 때, 즉 i가 홀수일 때는 '수'를, 짝수일 때는 '박'을<br/>
answer에 채워 출력하면 된다.<br/><br/>
이제 모두 완료한 것 같지만 마지막으로 해줄 일이 남았다.<br/><br/>
전통적인 C언어에서는 스택 영역에 선언된 변수(ex - 지역변수, 매개변수 등)는 따로 메모리 해제를 해주지 않아도<br/>
해당 블록이 종료가 됨 과 동시에 알아서 메모리 해제가 되지만, 반면 힙 영역에 동적으로 할당된 변수는<br/>
반드시 free() 함수를 사용하여 메모리 해제를 해주어야 한다. 즉, malloc 함수와 free 함수는 한 쌍이라고 할 수 있다.<br/><br/>
메모리 해제를 하지 않으면 메모리 내의 프로세스 무게가 더해져서 램에 남아있는 공간이 적어지게 되고,<br/>
언젠가는 프로그램이 다운되는 등 오류가 발생하게 된다. 이러한 오류를 메모리 누수(Memory Leak)라고 하는데,<br/>
이것을 방지하는 것은 개발자의 핵심 역량이라고 할 수 있으므로 많은 신경을 써야 한다.<br/><br/>
